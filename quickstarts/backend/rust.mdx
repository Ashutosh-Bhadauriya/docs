---
sidebarTitle: "Rust"
title: Integrate Hanko with Rust backend
---

## Get the Hanko API URL

Retrieve the API URL from the [Hanko console](https://cloud.hanko.io/).

<Note>If you are self-hosting Hanko you need to provide your own URL.</Note>

## Hanko Authentication with JWT

Upon a successful login, Hanko sends a cookie containing a JSON Web Token ([JWT](https://datatracker.ietf.org/doc/html/rfc7519)). You can use this JWT to authenticate requests on your backend.

### Steps to Authenticate Requests

1. \*\*Recover the kid from the user token.

2. **Retrieve the JSON Web Key Set ([JWKS](https://datatracker.ietf.org/doc/html/rfc7517)):** The JWKS has the public keys to verify the JWT. Fetch it from the Hanko API's `.well-known/jwks.json` endpoint.

3. \*\*Make sure there is a JWK from that list that kid match the user token kid.

4. **Verify the JWT:** Use the JWKS to verify the JWT.

### Rust-based Backend Example

Below is a sample middleware for a rust backend using the [reqwest library](https://github.com/seanmonstar/reqwest) and the [`jsonwebtoken library`](https://github.com/Keats/jsonwebtoken) package:

```rust
use jsonwebtoken::{decode, decode_header, Algorithm, DecodingKey, Validation};
use reqwest;
use serde::{Deserialize, Serialize};
use std::error::Error;

const JWKS_HANKO_END_POINTS: &str = "some-hanko-api/.well-known/jwks.json";
const JWT_AUDIENCE_DOMAIN: &str = "your-domain.com";

#[derive(Debug, Deserialize)]
struct Jwk {
    kty: String,
    kid: String,
    n: String,
    e: String,
    alg: String,
}

#[derive(Debug, Deserialize)]
struct Jwks {
    keys: Vec<Jwk>,
}

#[derive(Debug, Deserialize, Serialize, Clone)]
pub struct EmailInfo {
    pub address: String,
    pub is_primary: bool,
    pub is_verified: bool,
}

#[derive(Debug, Deserialize, Serialize, Clone)]
pub struct UserEmailJwtPayload {
    // The decoded hanko token informations
    pub aud: Vec<String>,
    pub email: EmailInfo,
    pub exp: i64,
    pub iat: i64,
    pub sub: String,
}

async fn fetch_jwks() -> Result<Jwks, Box<dyn Error>> {
    let response = reqwest::get(&JWKS_HANKO_END_POINTS.to_string()).await?;
    let jwks = response.json::<Jwks>().await?;
    Ok(jwks)
}

fn find_token_kid(token: &str) -> Result<String, Box<dyn Error>> {
    let header = decode_header(token)?;
    header.kid.ok_or_else(|| "Missing kid in header".into())
}

fn decode_token(jwk: &Jwk, token: &str) -> Result<UserEmailJwtPayload, Box<dyn Error>> {
    let decoding_key = DecodingKey::from_rsa_components(&jwk.n, &jwk.e)?;

    let mut validation = Validation::new(Algorithm::RS256);
    validation.set_audience(&[JWT_AUDIENCE_DOMAIN.to_string()]);

    let token_data = decode::<UserEmailJwtPayload>(token, &decoding_key, &validation)?;
    Ok(token_data.claims)
}

async fn validate_hanko_token(token: &str) -> Result<UserEmailJwtPayload, Box<dyn Error>> {
    let token_kid = find_token_kid(token)?;
    let jwks = fetch_jwks().await?;
    let matching_jwk = jwks.keys.iter().find(|jwk| jwk.kid == token_kid);

    match matching_jwk {
        Some(jwk) => decode_token(jwk, token),
        None => Err(format!("No matching JWK found for kid: {}", token_kid).into()),
    }
}

#[tokio::main]
async fn main() {
    // Depending on the framework used (axum, artix-web, rocket...) recover the hanko token from the request.
    let jwt_hanko_token = "some-hanko-user-token".to_string();

    match validate_hanko_token(&jwt_hanko_token).await {
        Ok(payload) => println!("Token is valid. Payload: {:?}", payload),
        Err(err) => eprintln!("Token validation failed: {}", err),
    }
}
```
